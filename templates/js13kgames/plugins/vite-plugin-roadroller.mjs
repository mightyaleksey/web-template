import { Packer } from 'roadroller'
import CleanCSS from 'clean-css'
import fs from 'fs'
import htmlMinify from 'html-minifier'
import path from 'path'
import posthtml from 'posthtml'

function inlineStyleTag (assets) {
  return tree => {
    const cleanCSS = new CleanCSS({ level: 2 })
    return tree.walk(handleNodes)

    function handleNodes (node) {
      if (node == null || typeof node !== 'object') return node
      if (node.tag !== 'link') return node

      const asset = assets.find(asset => node.attrs?.href?.endsWith(asset.fileName))
      if (asset != null) {
        const output = cleanCSS.minify(asset.source)
        if (output.errors.length > 0) throw output.errors[0]

        return { tag: 'style', content: output.styles }
      }

      return node
    }
  }
}

/**
 * posthtml plugin to remove script tags
 * for corresponding filenames
 */
function removeScriptTag (assets) {
  return tree => {
    return tree.walk(handleNodes)

    function handleNodes (node) {
      if (node == null || typeof node !== 'object') return node
      if (node.tag !== 'script') return node

      if (assets.some(asset => node.attrs?.src?.endsWith(asset.fileName))) {
        return null
      }

      return node
    }
  }
}

async function embedCSS (src, cssAssets) {
  const html = (await posthtml()
    .use(inlineStyleTag(cssAssets))
    .process(src)).html

  return html
}

/**
 * Packs JavaScript and html code.
 * Returns "<script>{packed code}<script>"
 */
async function embedJS (src, jsAssets) {
  const html = (await posthtml()
    .use(removeScriptTag(jsAssets))
    .process(src)).html

  const inputs = [
    {
      data: [`document.write('${html}');`]
        .concat(jsAssets.map(asset => asset.code.trim()))
        .join(''),
      type: 'js',
      action: 'eval'
    }
  ]
  const options = await (async () => {
    if (process.env.USE_RR_CONFIG) {
      const config = await fs.promises.readFile(
        path.join(__dirname, '../roadroller-config.json'),
        'utf8'
      )

      return JSON.parse(config)
    } else {
      return { allowFreeVars: true }
    }
  })()

  const packer = new Packer(inputs, options)
  await packer.optimize()

  const { firstLine, secondLine } = packer.makeDecoder()
  return `<script>\n${firstLine}\n${secondLine}\n</script>`
}

export function roadrollerPlugin () {
  return {
    name: 'vite:roadroller',
    transformIndexHtml: {
      order: 'post',
      /**
       * src - string
       * id - asset
       * id.path - string
       * id.filename - string
       * id.bundle - chunks
       */
      handler: async (src, id) => {
        if (!id || !id.bundle) return src

        const options = {
          collapseInlineTagWhitespace: true,
          collapseWhitespace: true,
          includeAutoGeneratedTags: true,
          minifyCSS: true,
          removeAttributeQuotes: true,
          removeComments: true,
          removeEmptyAttributes: true,
          removeOptionalTags: true,
          removeRedundantAttributes: true,
          removeScriptTypeAttributes: true,
          removeStyleLinkTypeAttributes: true,
          sortAttributes: true,
          sortClassName: true,
          useShortDoctype: true
        }

        const assets = Object.values(id.bundle)
        const cssAssets = assets
          .filter(asset => asset.fileName.endsWith('.css'))
        const jsAssets = assets
          .filter(asset => asset.fileName.endsWith('.js'))

        const remainingAssets = assets
          .filter(asset =>
            !asset.fileName.endsWith('.css') &&
            !asset.fileName.endsWith('.js')
          )
        remainingAssets.forEach(asset =>
          console.warn('Warn: asset is not inlined %s', asset.fileName)
        )

        const html = await htmlMinify.minify(
          (cssAssets.length > 0 ? await embedCSS(src, cssAssets) : src),
          options
        )

        return embedJS(html, jsAssets)
      }
    }
  }
}
