import { Packer } from 'roadroller'
import { defineConfig } from 'vite'
import { execFileSync } from 'child_process'
import { flowPlugin, esbuildFlowPlugin } from '@bunchtogether/vite-plugin-flow'
import CleanCSS from 'clean-css'
import ect from 'ect-bin'
import fs from 'fs'
import htmlMinify from 'html-minifier'
import path from 'path'

export default defineConfig(({ command }) => {
  switch (command) {
    case 'build':
      return {
        base: '',
        build: {
          minify: true,
          target: 'es2020',
          modulePreload: { polyfill: false },
          assetsInlineLimit: 800,
          assetsDir: '',
          rollupOptions: {
            output: {
              inlineDynamicImports: true,
              manualChunks: undefined,
              assetFileNames: '[name].[ext]'
            }
          }
        },
        esbuild: true,
        optimizeDeps: {
          esbuildOptions: {
            // plugin removes only types, however, enums are left intact
            // (additional transformation is required).
            plugins: [esbuildFlowPlugin()]
          }
        },
        plugins: [flowPlugin(), roadrollerPlugin(), ectPlugin()]
      }

    default:
      return {
        optimizeDeps: {
          esbuildOptions: {
            // plugin removes only types, however, enums are left intact
            // (additional transformation is required).
            plugins: [esbuildFlowPlugin()]
          }
        },
        plugins: [flowPlugin()]
      }
  }
})

/**
 * Transforms the given JavaScript code into a packed version.
 * @param html The original HTML.
 * @param chunk The JavaScript output chunk from Rollup/Vite.
 * @returns The transformed HTML with the JavaScript embedded.
 */
async function embedJs (html, chunk) {
  const scriptTagRemoved = html.replace(
    new RegExp(`<script[^>]*?src=[./]*${chunk.fileName}[^>]*?></script>`),
    ''
  )
  const htmlInJs = `document.write('${scriptTagRemoved}');` + chunk.code.trim()

  const inputs = [
    {
      data: htmlInJs,
      type: 'js',
      action: 'eval'
    }
  ]

  let options
  if (process.env.USE_RR_CONFIG) {
    try {
      options = JSON.parse(
        await fs.promises.readFile(path.join(__dirname, 'roadroller-config.json'), 'utf-8')
      )
    } catch (error) {
      throw new Error(
        'Roadroller config not found. Generate one or use the regular build option'
      )
    }
  } else {
    options = { allowFreeVars: true }
  }

  const packer = new Packer(inputs, options)
  await Promise.all([
    fs.promises.writeFile(`${path.join(__dirname, 'dist')}/output.js`, htmlInJs),
    packer.optimize(process.env.LEVEL_2_BUILD ? 2 : 0) // Regular builds use level 2, but rr config builds use the supplied params
  ])
  const { firstLine, secondLine } = packer.makeDecoder()
  return `<script>\n${firstLine}\n${secondLine}\n</script>`
}

/**
 * Embeds CSS into the HTML.
 * @param html The original HTML.
 * @param asset The CSS asset.
 * @returns The transformed HTML with the CSS embedded.
 */
function embedCss (html, asset) {
  const reCSS = new RegExp(
    `<link rel="stylesheet"[^>]*?href="[./]*${asset.fileName}"[^>]*?>`
  )
  const code = `<style>${
    new CleanCSS({ level: 2 }).minify(asset.source).styles
  }</style>`
  return html.replace(reCSS, code)
}

function roadrollerPlugin () {
  return {
    name: 'vite:roadroller',
    transformIndexHtml: {
      enforce: 'post',
      transform: async (html, ctx) => {
        // Only use this plugin during build
        if (!ctx || !ctx.bundle) {
          return html
        }

        const options = {
          includeAutoGeneratedTags: true,
          removeAttributeQuotes: true,
          removeComments: true,
          removeRedundantAttributes: true,
          removeScriptTypeAttributes: true,
          removeStyleLinkTypeAttributes: true,
          sortClassName: true,
          useShortDoctype: true,
          collapseWhitespace: true,
          collapseInlineTagWhitespace: true,
          removeEmptyAttributes: true,
          removeOptionalTags: true,
          sortAttributes: true,
          minifyCSS: true
        }

        const bundleOutputs = Object.values(ctx.bundle)
        const javascript = bundleOutputs.find((output) =>
          output.fileName.endsWith('.js')
        )

        const css = bundleOutputs.find((output) =>
          output.fileName.endsWith('.css')
        )
        const otherBundleOutputs = bundleOutputs.filter(
          (output) => output !== javascript
        )
        if (otherBundleOutputs.length > 0) {
          otherBundleOutputs.forEach((output) =>
            console.warn(`WARN Asset not inlined: ${output.fileName}`)
          )
        }

        const cssInHtml = css ? embedCss(html, css) : html
        const minifiedHtml = await htmlMinify.minify(cssInHtml, options)
        return embedJs(minifiedHtml, javascript)
      }
    }
  }
}

function ectPlugin () {
  return {
    name: 'vite:ect',
    writeBundle: async () => {
      try {
        const files = await fs.promises.readdir('dist/')
        const assetFiles = files
          .filter((file) => {
            return (
              !file.includes('.js') &&
              !file.includes('.css') &&
              !file.includes('.html') &&
              !file.includes('.zip') &&
              file !== 'assets'
            )
          })
          .map((file) => 'dist/' + file)
        const args = [
          '-strip',
          '-zip',
          '-10009',
          'dist/index.html',
          ...assetFiles
        ]
        const result = execFileSync(ect, args)
        console.log('ECT result', result.toString().trim())
        const stats = fs.statSync('dist/index.zip')
        console.log('ZIP size', stats.size)
      } catch (err) {
        console.log('ECT error', err)
      }
    }
  }
}
